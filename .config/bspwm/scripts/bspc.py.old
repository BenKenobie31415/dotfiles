#!/usr/bin/env python3
import subprocess
import threading
import socket
import os

socket_path = "/tmp/bspwm_0_0-socket"
try:
    socket_path = os.environ["BSPWM_SOCKET"]
except KeyError:
    pass

def __get_decoded_output(cmd: list[str]) -> list[str]:
    """Get the output of a command as a list of strings, where each string is a line of the output."""
    try:
        # [:-1] to remove the newline at the end
        return subprocess.check_output(cmd, encoding="utf-8")[:-1].split("\n")
    except subprocess.CalledProcessError:
        return []

def bspc(*command: str):
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.connect(socket_path)
    cmd = b"\x00".join(argument.encode("utf-8") for argument in command)
    client.send(cmd + b"\x00")
    data = client.recv(4096).decode("utf-8")
    client.close()
    # [:-1] to remove the newline at the end
    return data.split("\n")[:-1]

def get_occupied_desktop_ids() -> list[str]:
    return bspc("query", "-D", "-d", ".occupied")

def get_focused_desktop() -> str:
    return bspc("query", "-D", "-d")[0]

def get_desktop_name(desktop_id: str) -> str:
    return bspc("query", "-D", "-d", desktop_id, "--names")[0]

def focus_desktop(desktop_id: str) -> None:
    bspc("desktop", "-f", desktop_id)

def get_focused_window() -> str:
    return bspc("query", "-N", "-d")[0]

def focus_node(node_id: str, desktop_id: str) -> None:
    if node_id not in get_window_ids(desktop_id):
        return
    bspc("node", "-f", node_id)

def get_pointed_window() -> str:
    window = bspc("query", "-N", "-d", "-n", "pointed.window")
    if window == []:
        return None
    return window[0]

def get_root_node() -> str:
    node = bspc("query", "-N", "-d", "-n", "@focused:/")
    if node == []:
        return None
    return node[0]

def get_window_ids(desktop_id: str, excluded: list[str]=[]) -> list[str]:
    ids = bspc("query", "-N", "-d", desktop_id, "-n", ".window")
    return [id for id in ids if not id in excluded]


def get_desktop_ids() -> list[str]:
    return bspc("query", "-D")

def get_first_free_desktop_id() -> str:
    free_desktops = bspc("query", "-D", "-d", ".!occupied")
    if len(free_desktops) == 0:
        return ""
    return free_desktops[0]

def focus_next_free_desktop() -> None:
    focus_desktop(get_first_free_desktop_id())

def rename_desktop(name: str, desktop_id: str) -> None:
    bspc("desktop", desktop_id, "-n", name)

def set_node_flag(node_id: str, flag: str, value: str, desktop_id: str) -> None:
    if node_id not in get_window_ids(desktop_id):
        return
    bspc("node", node_id, "-g", flag + "=" + value)

def get_window_names(desktop_id: str) -> list[str]:
    window_ids = get_window_ids(desktop_id)
    if len(window_ids) == 0:
        return []
    cmd = ["xtitle"]
    cmd.extend(window_ids)
    return __get_decoded_output(cmd)

def get_node_name(node_id) -> str:
    if node_id not in get_window_ids(get_focused_desktop()):
        return "node does not exist"
    cmd = ["xtitle"]
    cmd.extend([node_id])
    title = __get_decoded_output(cmd)[0]
    return title

def get_first_window_with_name(window_name: str, desktop_id: str) -> str:
    window_ids = get_window_ids(desktop_id)
    for window_id in window_ids:
        if (get_node_name(window_id) == window_name):
            return window_id
    return None

def is_desktop_empty_except(excluded_names: list[str], desktop_id: str) -> bool:
    windows = get_window_ids(desktop_id)
    for window in windows:
        if get_node_name(window) not in excluded_names:
            return False
    return True

def __add_subscriber(event:str, callback, *callback_args):
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.connect(socket_path)
    client.send(b"subscribe\x00" + event.encode() + b"\x00")
    while True:
        # [:-1] to remove the newline at the end
        data = client.recv(4096).decode("utf-8")[:-1]
        if data:
            # [1:] to remove the event name
            args = data.split(" ")[1:]
            callback(args, *callback_args)

def subscribe(event:str, callback, *callback_args):
    """Subscribe to an event and call the callback when the event is triggered.
        Callback should take the event arguments (list[str]) as the first argument, and any other arguments as the rest."""
    t = threading.Thread(target=__add_subscriber, args=(event, callback, *callback_args))
    t.start()
