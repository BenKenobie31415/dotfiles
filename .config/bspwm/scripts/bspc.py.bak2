#!/usr/bin/env python3
import subprocess
import threading
import socket
import os
from bspc_lib import *

socket_path = "/tmp/bspwm_0_0-socket"
try:
    socket_path = os.environ["BSPWM_SOCKET"]
except KeyError:
    pass

def __get_decoded_output(cmd: list[str]) -> list[str]:
    """Get the output of a command as a list of strings, where each string is a line of the output."""
    try:
        # [:-1] to remove the newline at the end
        return subprocess.check_output(cmd, encoding="utf-8")[:-1].split("\n")
    except subprocess.CalledProcessError:
        return []

def bspc(*command: str):
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.connect(socket_path)
    cmd = b"\x00".join(argument.encode("utf-8") for argument in command)
    client.send(cmd + b"\x00")
    data = client.recv(4096).decode("utf-8")
    client.close()
    # [:-1] to remove the newline at the end
    return data.split("\n")[:-1]

#State-Checker
#Monitor querys
def get_monitor_ids() -> list[str]:
    return bspc("query", "-M")

def get_focused_monitor() -> str:
    return bspc("query", "-M", "-m")[0]

def get_monitor_id(port: str) -> str:
    return bspc("query", "-M", "-m", port)[0]

#Desktop querys
def get_desktop_ids(monitor_id: str = None) -> list[str]:
    if monitor_id:
        return bspc("query", "-D", "-m", monitor_id)
    else:
        return bspc("query", "-D")

def get_focused_desktop() -> str:
    return bspc("query", "-D", "-d")[0]

def get_active_desktops() -> list[str]:
    return bspc("query", "-D", "-d", ".active")

def get_desktop_name(desktop_id: str) -> str:
    return bspc("query", "-D", "-d", desktop_id, "--names")[0]

def get_first_free_desktop_id() -> str:
    free_desktops = bspc("query", "-D", "-d", ".!occupied")
    if len(free_desktops) == 0:
        return ""
    return free_desktops[0]

def get_active_desktop(monitor_id: str) -> str:
    if not monitor_id:
        return None
    for desktop in get_active_desktops():
        if get_monitor_of_desktop(desktop) == monitor_id:
            return desktop
    return None

def get_desktop_of_node(node_id: str) -> str:
    for desktop_id in get_desktop_ids():
        if node_id in get_node_ids(desktop_id):
            return desktop_id
    return None

#Window querys
#TODO make desktop modifiers more modular not just desktop-id
def get_node_ids(desktop_id: str=None, excluded: list[str]=[], node_modifiers: list[NodeModifiers]=[NodeModifiers.WINDOW]) -> list[str]:
    node_modifier_str = ""
    for node_modifier in node_modifiers:
        node_modifier_str += node_modifier.value
    if desktop_id:
        ids = bspc("query", "-N", "-d", desktop_id, "-n", node_modifier_str)
    else:
        ids = bspc("query", "-N", "-n", node_modifier_str)
    return [id for id in ids if not id in excluded]

def get_focused_window() -> str:
    return bspc("query", "-N", "-d")[0]

def get_occupied_desktop_ids() -> list[str]:
    return bspc("query", "-D", "-d", ".occupied")

def get_pointed_window() -> str:
    window = bspc("query", "-N", "-d", "-n", "pointed.window")
    if window == []:
        return None
    return window[0]

def get_root_node() -> str:
    node = bspc("query", "-N", "-d", "-n", "@focused:/")
    if node == []:
        return None
    return node[0]

def get_node_name(node_id: str, desktop_id: str) -> str:
    if node_id not in get_node_ids(desktop_id, node_modifiers=[]):
        return "node does not exist"
    cmd = ["xtitle"]
    cmd.extend([node_id])
    title = __get_decoded_output(cmd)[0]
    return title

def get_window_names(desktop_id: str) -> list[str]:
    window_ids = get_node_ids(desktop_id, node_modifiers=["window"])
    if len(window_ids) == 0:
        return []
    cmd = ["xtitle"]
    cmd.extend(window_ids)
    return __get_decoded_output(cmd)

def get_first_window_with_name(window_name: str, desktop_id: str = None) -> str:
    if desktop_id:
        desktop_ids = [desktop_id]
    else:
        desktop_ids = get_desktop_ids()
    for desktop_id in desktop_ids:
        window_ids = get_node_ids(desktop_id)
        for window_id in window_ids:
            if (get_node_name(window_id, desktop_id) == window_name):
                return window_id
    return None

def get_monitor_of_desktop(desktop_id: str) -> str:
    monitor_ids = get_monitor_ids()
    for monitor_id in monitor_ids:
        if desktop_id in get_desktop_ids(monitor_id):
            return monitor_id
    return None

#State checker
def is_desktop_empty_except(excluded_names: list[str], desktop_id: str) -> bool:
    windows = get_node_ids(desktop_id)
    for window in windows:
        if get_node_name(window, desktop_id) not in excluded_names:
            return False
    return True

def is_desktop_occupied(desktop_id: str, excluded_ids: list[str] = []) -> bool:
    return len(get_node_ids(desktop_id, excluded=excluded_ids)) > 0


#State-Setter
def focus_desktop(desktop_id: str) -> None:
    bspc("desktop", "-f", desktop_id)

def focus_node(node_id: str, desktop_id: str) -> None:
    if node_id not in get_node_ids(desktop_id):
        return
    bspc("node", "-f", node_id)

def focus_next_free_desktop() -> None:
    focus_desktop(get_first_free_desktop_id())

def rename_desktop(name: str, desktop_id: str) -> None:
    bspc("desktop", desktop_id, "-n", name)

def set_node_flag(node_id: str, flag: str, value: str, desktop_id: str) -> None:
    if not node_id or not desktop_id:
        return
    if node_id not in get_node_ids(desktop_id):
        return
    bspc("node", node_id, "-g", flag + "=" + value)

def __add_subscriber(event:str, callback, *callback_args):
    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    client.connect(socket_path)
    client.send(b"subscribe\x00" + event.encode() + b"\x00")
    while True:
        # [:-1] to remove the newline at the end
        data = client.recv(4096).decode("utf-8")[:-1]
        if data:
            # [1:] to remove the event name
            args = data.split(" ")[1:]
            callback(args, *callback_args)

def subscribe(event:str, callback, *callback_args):
    """Subscribe to an event and call the callback when the event is triggered.
        Callback should take the event arguments (list[str]) as the first argument, and any other arguments as the rest."""
    t = threading.Thread(target=__add_subscriber, args=(event, callback, *callback_args))
    t.start()
